// = Your Blog title
// See https://hubpress.gitbooks.io/hubpress-knowledgebase/content/ for information about the parameters.
// :hp-image: /covers/cover.png
// :published_at: 2019-01-31
// :hp-tags: HubPress, Blog, Open_Source,
// :hp-alt-title: My English Title

= Inyector DLL

A penas comenzar algunos estarán rodeados de dudas y preguntas, así que, iniciaré dando algunas definiciones de manera rápida y ligera, para que todos marchemos al mismo paso. Este post estará dedicado al desarrollo de un Inyector DLL.

== DLL (Dynamic Link Library)

Son archivos que contienen código ejecutable y datos que pueden ser usados por uno o más programas. Mediante el uso de DLL, un programa puede ser modularizado en componentes separados. Exclusivos de los sistemas operativos Windows, tienen ".dll" como extensión.
Inyección DLL

Es una técnica utilizada para ejecutar código dentro de otro proceso. Comúnmente es utilizada para influir o alterar el comportamiento de un programa.

== Inyector DLL

Es el programa usado para llevar acabo la Inyección DLL.
 
Existen diversas formas o técnicas para inyectar DLL's, en este post explicare la más utilizada. Esta consiste en lo siguiente; Windows provee funciones para crear un hilo en cierta posición de memoria de un proceso externo, para ello reservamos memoria en el proceso, escribimos en ella la ruta de la DLL que queremos inyectar y creamos un hilo pasandole como parámetros el proceso, la dirección de memoria donde se encuentra la función LoadLibrary y la dirección de memoria que reservamos que escribimos anteriormente.
 
Para el desarrollo de este programa haremos uso del lenguaje de programación C++, aun  que no hace falta conocerlo para seguir el post, basta con tener conocimientos de POO.

== Herramientas

    * IDE para C/C++
    * Compilador para C/C++

Yo utilizare CodeBlocks con MinGW (implementación de los compiladores GCC) de 32 bit para Windows, ambos los puedes descargar desde aquí.
 

Sin más preámbulo pasemos a la parte que todos esperaban (hay así XD).

== Proyecto 1: Inyector

=== Injector.h

[code language="cpp"]
#ifndef INJECTOR_H
#define INJECTOR_H

class Injector
{
public:
void inject(char *dll, char *process);
};

#endif // INJECTOR_H
[/code]

=== Injector.cpp

[code language="cpp"]
#include <windows.h>

#include "Injector.h"

// Función que lleva acabo la inyección
void Injector::inject(char *dll, char *windowTitle)
{
HWND window;
DWORD pid;
HANDLE process;
LPVOID memory;
SIZE_T write = 0;

// Buscamos la ventana del proceso a inyectar
window = FindWindowEx(0, 0, 0, windowTitle);

// Buscamos el proceso a inyectar
GetWindowThreadProcessId(window, &pid);

// Abrimos el proceso
process = OpenProcess(PROCESS_ALL_ACCESS, false, pid);

// Reservamos memoria en el proceso para la DLL
memory = VirtualAllocEx(process, 0, strlen(dll),
MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);

// Escribimos en el proceso
WriteProcessMemory(process, memory, (LPVOID)dll, strlen(dll), &write);

// Obtenemos el modulo de la DLL Kernel32
HMODULE hModule = LoadLibrary("Kernel32.dll");
// Obtenemos la dirección en memoria en la que se encuentra la
// función LoadLibrary
FARPROC tsr = GetProcAddress(hModule, "LoadLibraryA");

// Creamos un hilo en el proceso
CreateRemoteThread(process, 0, 0, (LPTHRED_START_ROUTINE)tsr,
memory, 0, 0);
}
[/code]

=== Main.cpp

[code language="cpp"]
#include <cstring>
using std::strcpy;

#include <iostream>
using std::cout;
using std::cin;

#include <string>
using std::string;

#include "Injector.h"

int main()
{
string aux;

// Pide la ruta de la DLL
cout << "Path DLL: ";
// Lee la ruta y la coloca en aux
cin >> aux;

// Convierte la variable aux a char*
char *dll = new char[aux.length() + 1];
strcpy(dll, aux.c_str());

// Pide el título de la ventana
cout << "Window Title: ";
// Lee el título de la ventana y lo coloca en aux
cin >> aux;

// Convierte la variable aux a char*
char *windowTitle = new char[aux.length() + 1];
strcpy(windowTitle, aux.c_str());

// Instancia un objeto de la clase Injetor
Injector injector;
// Llama al método inject
injector.inject(dll, windowTitle);

delete [] dll;
delete [] windowTitle;

return 0;
}
[/code]

== Proyecto 2: DLL

=== Main.cpp

[code language="cpp"]
#include <windows.h>

// Función que muestra un cuadro de dialogo
void message()
{
MessageBoxA(0, "Bienvenido a Quickhub!", "DLL Message", 0);
}

BOOL APIENTRY DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved)
{
switch (fdwReason)
{
case DLL_PROCESS_ATTACH:
// attach to process
// return FALSE to fail DLL load

// Crea un hilo
CreateThread(0, 0, (LPTHREAD_START_ROUTINE)message, 0, 0, 0);
break;

case DLL_PROCESS_DETACH:
// detach from process
break;

case DLL_THREAD_ATTACH:
// attach to thread
break;

case DLL_THREAD_DETACH:
// detach from thread
break;
}

return TRUE; // succesful
}
[/code]

IMPORTANTE: si el programa en el vamos a realizar la inyección es de 32 bit, la DLL a inyectar debe ser compilada para 32 bit. Pasa lo mismo con los programas de 64 bit. No podemos inyectar una DLL compilada para 32 bit en un programa de 64 bit, ni viceversa.

== Demostración

Seguramente más de uno esté pensando, ¿Qué utilidad tiene agregar un cuadro de dialogo?. Una ballena se devora un mordisco a la vez. En mi siguiente post haremos más que agregar un simple cuadro de dialogo, haremos nuestros propios hacks para videojuegos.

== Referencias

DLL - Wikipedia
What is a DLL? - Microsoft
DLL injection - Wikipedia
FindWindowEx - Microsoft
GetWindowThreadProcessId
OpenProcess - Microsoft
VirtualAllocEx - Microsoft
WriteProcessMemory - Microsoft
LoadLibrary - Microsoft
GetProcAddress - Microsoft
CreateRemoteThread - MIcrosoft